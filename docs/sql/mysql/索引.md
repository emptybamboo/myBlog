
## 索引

### 概念

- 索引是表的目录，在查找内容之前可以先在目录中查找索引位置，以此快速定位查询数据。对于索引，会保存在额外的文件中。 

- 索引，是数据库中专门用于帮助用户快速查询数据的一种数据结构。**类似于字典中的目录**，查找字典内容时可以根据目录查找到数据的存放位置，然后直接获取即可。 

  > 1. 越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快。 
  > 2. 简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂。 
  > 3. 尽量避免NULL：应该指定列为NOT nuLL,在MySQL中， **含有空值的列很难进行查询优化**，因为它们使得索引、索引的统计信息以及比较运算更加复杂 

#### 不适合创建索引的情况

1. 对于那些在查询中很少使用或者参考的列不应该创建索引。 
2. 对于那 些只有很少数据值的列也不应该增加索引。因为本来结果集合就是相当于全表查询了，所以没有必要。 
3. 对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 
4. 当修改性能远远大于检索性能时，不应该创建索引。 
5. 不会出现在where条件中的字段不该建立索引 

#### 适合创建索引的情况

1. 表的主键、外键必须有索引；**外键是唯一的，而且经常会用来查询** 
2. 数据量超过300的表应该有索引； 
3. 经常与其他表进行连接的表，在连接字段上应该建立索引；**经常连接查询，需要有索引**
4. 经常出现在Where子句中的字段，加快判断速度，特别是大表的字段，应该建立索引，建立索引，一般用在select ……where f1 and f2 ，我们在f1或者f2上建立索引是没用的。**只有两个使用联合索引才能有用** 
5. **经常用到排序的列上**，因为索引已经排序。 
6. **经常用在范围内搜索的列上创建索引**，因为索引已经排序了，其指定的范围是连续的 

### 索引优缺点

#### 优点

- 索引由数据库中一列或多列组合而成，其作用是提高对表中数据的查询速度 

#### 缺点

- 索引的缺点是创建和维护索引需要耗费时间 
- 可以提高查询速度，会减慢写入速度 
- 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。**一个表的索引数最好不要超过6个**，若太多则应考虑一些不常使用到的列上建的索引是否有必要。

### 索引分类

1. **普通索引**

> 仅加速查询 最基本的索引，没有任何限制，是我们大多数情况下使用到的索引。

```sql
CREATE INDEX  index_name  on user_info(name)  ;
```

​	注意: 对于创建索引时如果是blob 和 text 类型，必须指定length。 

```sql
create index ix_extra on in1(message(200));

alter table employee add index emp_name (name);
```

​	删除索引

```sql
drop index_name on healerjean;

alter TABLE users  drop index  name_index ;
```

​	查看索引

```sql
show index from table;
```

2. **唯一索引**

> 与普通索引类型，不同的是：加速查询 + 列值唯一（可以有null）

```sql
CREATE UNIQUE INDEX  mail  on user_info(name)  ;
```

3. **全文索引**

> 全文索引（FULLTEXT）仅可以适用于MyISAM引擎的数据表；作用于CHAR、VARCHAR、TEXT数据类型的列。

4. **组合索引**

> 将几个列作为一条索引进行检索，使用最左匹配原则。

### 正确使用索引

- 在查询语句前加explain,看explain中出现的row有有多少行,行数越多,表示执行速度越慢 
- 如果以错误的方式使用，则即使建立索引也会不奏效。

#### 对于创建的多列索引,只要查询的条件中用到了最左边的列,索引一般就会被使用

- 意思是假如现在有一个薪水表salary,里面有两个字段id和adid,这两个字段组成一个联合索引,在select查询语句中,即使where后面的等于条件只有一个id(居左的列),索引依然成立.但是如果where后只使用adid为条件,索引就不会被使用.

#### 对于使用 like 的查询,后面如果是常量并且%号不在第一个字符,索引才可能会被使用

```mysql
explain select * from company2 where name like '%3'\G;

explain select * from company2 where name like '3%'\G;
```

- 第一个例子没有使用索引,而第二例子就能够使用索引, 
- 区别就在于“%”的位置不同,前者把“%”放到第一位就不能用到索引,而后者没有放到第一位就使用了索引。 

#### 如果列名,是索引,使用 column_name is null 将使用索引。

- 列名就是字段名

  ```mysql
  explain select * from company2 where name is null\G;
  ```

#### 如果对大的文本进行搜索,使用全文索引而不用使用 like ‘%…%’

### 存在索引,但是不使用

#### 如果 MySQL 估计使用索引比全表扫描更慢,则不使用索引。例如，如果列key_part1 均匀分布在 1 和 100 之间,下列查询中使用索引就不是很好

```mysql
SELECT * FROM table_name where key_part1 > 1 and key_part1 < 90;
```

#### 用 or 分割开的条件,如果 or 前的条件中的列有索引,而后面的列中没有索引,那么涉及到的索引都不会被用到,例如:必须or前后都有索引才能被使用，而且必须是单独索引。

```mysql
explain select * from company2 where name = 294\G;//使用索引

explain select * from company2 where name = '294'\G;//不使用索引

```

### 联合索引

#### 精确查找联合索引总结

1. 顾名思义是最左优先，以**最左边的为起点**任何连续的索引都能匹配上 

2. 多个单列索引在多条件查询时只会生效第一个索引！所以多条件联合查询时最好建联合索引！

   当创建**(a,b,c)联合索引时**，相当于创建了**(a)单列索引**，**(a,b)联合索引**以及**(a,b,c)联合索引**
   想要索引生效的话,只能使用 a和a,b和a,b,c三种组合；当然，我们上面测试过，a,c组合也可以，但实际上只用到了a的索引，c并没有用到！

3. 具体使用 a b c 的顺序无关，mysql会自动优化，但是我们建议按照索引的顺序进行查询，而且尽量将筛选力度大的放到前面，其实这种也不要一定是准确的，其实真正有影响的是是否用到了索引 

### 单列索引

- 查询条件为 name：使用到了索引 name（长度为512 = 4 * 128 + 2）

  ```mysql
  explain  SELECT * from d001_index WHERE name = 'zhangyj' ;
  
  ```

- 查询条件为 name 、 age ：只使用了第一个 name索引（长度为512 = 4 * 128 + 2）

  ```mysql
  explain  SELECT * from d001_index WHERE name = 'zhangyj' and age = 3 ;
  
  ```

- 查询条件为 name or age ：两个索引都用上了 type = INDEX_MERGE 合并索引

> index merge 技术如果简单的说，其实就是：**对多个索引分别进行条件扫描，然后将它们各自的结果进行合并(intersect/union)**。 

```mysql
explain  SELECT * from d001_index WHERE name = 'zhangyj' or age = 3 ;

```

### 联合索引范围查询

- 范围查询使用到第几列，则联合索引该列后面的字段的不能使用索引

- a > 3 使用了索引 a （长度为 5 ）

  ```mysql
  explain  SELECT * from d001_index WHERE a > 3  ; 使用到了索引
  
  ```

- a = 1 and b > 1 ：使用了联合索引 a、b（长度为10）

  ```mysql
  explain SELECT * from d001_index WHERE a = 1 and  b > 1 ;
  
  ```

- a = 5 AND b > 6 AND c = 7 ：使用了联合索引 a、b（长度为10）

  ```mysql
  explain SELECT * from d001_index WHERE a = 5 AND b > 6 AND c = 7
  
  ```

#### 可以用到索引的情况

- A>5 
- A=5 AND B>6 
- A=5 AND B=6 AND C=7 

#### 下面的条件将不能用上组合索引查询

- B>5 ——查询条件不包含组合索引首列字段 
- B=6 AND C=7 ——查询条件不包含组合索引首列字段 

#### 下面条件将能用上部分组合索引查询

- A>5 AND B=2 ——当范围查询使用第一列，查询条件仅仅能使用第一列 A 
- A=5 AND B>6 AND C=2 ——范围查询使用第二列，查询条件仅仅能使用前二列    A ,B 